two choices with conditions going to same function, but different variables
the function is recursive as described in tests
but one of the variables returns redundant and the other doesnt
hence hitting two birds with one stone

this doesnt count as repetition as the first branches are the same
in addition, lemmas only save the redundant branch conditions

object util {
  def repeat(x : Int): Boolean ={
    if (x < 5){
      repeat(x+1)
    }
    else {
      check(x)
    }
  }
  def check(x : Int): Boolean ={
    x == 5
  }
}

def recur(x : Int): Boolean ={
    if (x < 5){
      recur(x+1)
    }
    else {
      check(x)
    }
  }



S_recur = +{
    !Offer().&{
        ?Option1(x : Int)[x < 5].+{
            !Accept1()[util.noRecur(x)],
            !Reject1()[!util.noRecur(x)]
        },
        ?Option2(x : Int)[x >= 5].+{
            !Accept2()[util.noRecur(x)],
            !Reject2()[!util.noRecur(x)]
        }
    }
}


Accept1 and Reject2 should be left

what i can do is take the condition and its negation, assert the conditions to their respective blocks and be like "this or this"

(
    assert (
        let (
            (
                a!1 (
                    and (
                        and (
                            > n 0
                        ) (
                            not (
                                = x 0
                            )
                        )
                    )
                    (= n n1)
                    (= x x1)
                    (>
                        (
                            * (
                                + x1
                            ) n1
                        ) 0
                    )
                )
            )
              (a!2 (not (and (> n 0) (not (= x 0)))))
              (a!3 (and (and (< n 0) (not (= x 0))) (> (* (+ x) (- 0 n)) 0)))
              (a!4 (not (and (< n 0) (not (= x 0))))))
        (let ((a!5 (and a!2 (or a!3 (and a!4 (>= x 0))))))
          (and (not (and (= n n) (= x x) (or a!1 a!5))) (>= x 0)))))


