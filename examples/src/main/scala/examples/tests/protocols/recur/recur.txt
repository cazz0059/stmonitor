two choices with conditions going to same function, but different variables
the function is recursive as described in tests
but one of the variables returns redundant and the other doesnt
hence hitting two birds with one stone

this doesnt count as repetition as the first branches are the same
in addition, lemmas only save the redundant branch conditions


// very dumb test
// the goal is to unfold the loops and functions correctly
// and find the redundancy when compared to the conditions in the corresponding branch trace

// recursion wont work because the functions have the same names

old version reject1 and accept2 are kept
new version accept1 and reject2 are kept
table saved in sep text file is with error, check call in first condition

object util {
  def repeat(x : Int): Boolean ={
    if (x < 5){
      repeat(x+1)
    }
    else {
      check(x)
    }
  }
  def check(x : Int): Boolean ={
    x == 5
  }
}

def recur(x : Int): Boolean ={
    if (x < 5){
      recur(x+1)
    }
    else {
      check(x)
    }
}



S_recur = +{
    !Offer().&{
        ?Option1(x : Int)[x < 5].+{
            !Accept1()[util.noRecur(x)],
            !Reject1()[!util.noRecur(x)]
        },
        ?Option2(x : Int)[x >= 5].+{
            !Accept2()[util.noRecur(x)],
            !Reject2()[!util.noRecur(x)]
        }
    }
}


Accept1 and Reject2 should be left

what i can do is take the condition and its negation, assert the conditions to their respective blocks and be like "this or this"

(
    assert (
        let (
            (
                a!1 (
                    and (
                        and (
                            > n 0
                        ) (
                            not (
                                = x 0
                            )
                        )
                    )
                    (= n n1)
                    (= x x1)
                    (>
                        (
                            * (
                                + x1
                            ) n1
                        ) 0
                    )
                )
            )
              (a!2 (not (and (> n 0) (not (= x 0)))))
              (a!3 (and (and (< n 0) (not (= x 0))) (> (* (+ x) (- 0 n)) 0)))
              (a!4 (not (and (< n 0) (not (= x 0))))))
        (let ((a!5 (and a!2 (or a!3 (and a!4 (>= x 0))))))
          (and (not (and (= n n) (= x x) (or a!1 a!5))) (>= x 0)))))



//  def noRecur1(x : Int, n : Int) : Boolean = {
//    if((n > 0) && (x != 0)){
//      check(x, n)
//    }
//    else if ((n < 0) && (x != 0)){
//      check(x, -n)
//    }
//    else {
//      x >= 0// (n == 0) || (x == 0)
//    }
//  }

//  	if(x >= 0){
//			true // x >= 0
//  	}
//  	else {
//			false
//  	}


//  def check2(x2 : Int): Boolean ={
//    x2 != 5
//  }